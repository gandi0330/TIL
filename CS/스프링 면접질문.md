### 스프링 프레임워크을 설명하세요
- 자바 엔터프라이즈 개발을 편하게 해주는 경량급 오픈소스 애플리케이션 프레임워크
- 대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부 표준 프레임워크
- POJO 기반의 개발을 쉽고 편하게 해줌


### Spring, Spring MVC, SPring Boot 차이


### Bean을 설명하세요
- Spring에서 POJO를 bean이라고 부른다
- Spring IoC 컨테이너에 의해 관리된다
- 컨테이너 안에 들어있는 객체
- 필요할 때 컨테이너에서 가져와 사용
- @Bean을 사용하거나 xml설정으로 일반 객체를 Bean으로 등록할 수 있고 등록한 객체들을 쉽게 주입하여 사용

### Spring Bean의 생명주기
- 객체 생성 -> 의존 설정 -> 초기화 -> 사용 -> 소멸
- 스프링 컨테이너에 의해 생명주기 관리
- 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화
- 스프링 컨테이너 종료 시 빈 객체 소멸

### Spring Bean의 Scope를 설명하세요
- Singleton(default)
   - 어플리케이션에서 Bean 등록 시 기본으로 singleton scope로 등록
   - Spring Ioc 컨테이너당 한 개의 인스턴스만 생성
   - 컨테이너가 Bean을 가져다 주입할 때 항상 같은 객체를 사용
   - 메모리나 성능  최적화에 유리

- Prototype
   - 컨테이너에서 Bean을 가져다 쓸 때 항상 다른 인스턴스 사용
   - 모든 요청에서 새로운 객체 생성
   - gc에 의해 bean 제거

##### Spring MVC Web Application에서만 사용

- Request
  - Bean 등록 시 하나의 HTTP request 에 하나의 Bean만 존재
  - 각 HTTP 요청은 고유 Bean 객체 보유
  - Spring MVC Web Application에서 사용
- Session
- Global Session

### Autowire 과정을 설명하세요


### DispatcherServlet의 동작원리를 설명하세요
> Http 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트컨트롤러

- 클라이언트로부터 요청이 들어오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받는다
- 이 서블릿 컨테이너의 젤 앞에서 요청을 받아 적합한 컨트롤러에게 요청한다

- 장점
   - 프론트 컨트롤러 패턴의 장점을 그대로 가져온다(모든 요청을 핸들링 하며, 공통의 작업 처리로 중복 코드 없애기)

- 정적 자원에 대한 요청까지 Dispatcher Servlet으로 주는 것은 비효율적이다
- 해결책 두가지
   - 클라이언트의 요청을 url로 구분
      - /apps로 접근하면 Dispatcher Servlet이 담당
      - /resources로 접근하면 정적 자원을 제공
      - 모든 요청에 url을 붙여야 하므로 비효율적
   - 해당 요청을 처리할 컨트롤러를 찾고 없다면 2차적으로 자원 경로에서 자원을 탐색

- Dispatcher Servlet 동작과정
   - 1. 클라이언트의 요청을 디스패처 서블릿이 받는다
   - 2. 디스패처 서블릿이 Handler Mapping에게 요청하여 HandlerMethod를 찾고 HandlerMethodExcutionChain으로 감싼 후 반환한다
   - 3. HandlerMethodExcutionChain를 통해 인터셉터를 모두 실행한 후 HandlerAdapter가 전처리(ArgumentResolver를 통해 RequestParam과 ResquestBody등을 처리)후 컨트롤러의 메소드를 호출한다
   - 4. 컨트롤러는 비즈니스 로직을 수행한 후 view 이름이나 ResponseEntity를 반환한다
   - 5. HandlerAdapter는 ReturnValueHandler로 컨트롤러가 반환한 타입에 따라 데이터를 변환하여 디스패치 서블릿에게 리턴한다. 만약 ResponseEntity를 반환하면 응답 객체를 직렬화하고 응답 상태를 설정
   - 6. 디스패처 서블릿이 데이터를 반환한다

### 프론트 컨트롤러 패턴을 설명하세요
- 기존에 클라이언트는 비즈니스 로직을 수행하는 각각의 컨트롤러를 호출했다
- 유저 관련은 유저 컨트롤러.. 등등


- 프론트 컨트롤러는 클라이언트가 하나의 프론트 컨트롤러에 요청을 보내고 프론트 컨트롤러가 공통의 코드를 처리한 후 나머지 부분을 각 컨트롤러로 보내 처리하는 것
- 스프링 웹 MVC의 DispatcherServlet도 FrontContoller 패턴으로 구현됨



### Bean/Component 어노테이션을 설명하세요

- @Component : 개발자가 작성한 class의 인스턴스를 싱글톤으로 생성
- @Controller, @Service, @Repository는 모두 @Component이며 실행 시점에 자동으로 의존성 주입
- @Bean 개발자가 작성한 method를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체로 1회 생성(싱글톤)

### 의존성과 설정값을 생성자로 주입하는 이유를 설명하세요


### JPA의 영속성 컨텍스트를 설명하세요
- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미합니다
- 영속성 컨텍스트를 쓰는 이유는 1차캐시, 동일성 보장, 쓰기지연, 변경감지, 지연로딩이 있습니다.
   - 1차 캐시 : 조회가 가능하며 1차 캐시에 없으면 DB에 조회하여 1차 캐시에 올려놓는다
   - 동일성 보장 : 동일성 비교가 가능합니다
   - 쓰기 지연 : 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다
   - 변경 감지(Dirty checking) : 스냅샷을 1차 캐시에 들어온 데이터를 찍고 commit 되는 시점에서 Entity와 스냅샷을 비교하여 update SQL문을 생성
   - 지연 로딩 : 엔티티에서 해당 엔티티를 불러올 때에 SQL을 날려 해당 데이터를 가져온다

### JPA를 쓰는 이유, ORM 
- JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하지 않고 자바코드로 표현될 수 있기 때문
- JPA는 JPQL로 SQL을 추상화하기 때문에 

### JPA Propagation 전파단계를 설명하세요


### N+1문제를 설명하세요
- 연관 관계에서 발생하는 이슈
- 연관관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어옴


### IOC(Inversion of Control)을 설명하세요
> 객체의 생성에서부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미

- 대부분의 프레임워크에서 사용하는 방법으로 개발자는 필요한 부분을 끼워넣기의 형태로 개발하고 실행한다
- 조립된 코드는 프레임워크의 내부에서 결정된 대로 이뤄지고 이를 제어의 역전이라 한다
- 보통 라이브러리와 프레임워크의 차이를 제어의 역전으로 표현한다
  - 라이브러리는 개발자가 애플리케이션의 흐름을 직접 제어하며 필요한 기능이 있을때 능동적으로 사용한다
  - 프레임워크는 프레임워크가 애플리케이션의 흐름을 주도하면서 개발자가 작성한 코드를 사용한다

- Spring에서 Ioc
  - Spring 프레임워크에서 지원하는 Ioc Container는 POJO의 생명주기를 관리하며 생성된 인스턴스들에게 기능을 제공한다


### MVC 패턴을 설명하세요
> 디자인 패턴중 하나로 하나의 애플리케이션을 Model, View, Controller 세가지 역할로 구분한 패턴이다


- 컨트롤러는 모델을 통해 데이터를 가져오거나 조작하고 그 데이터를 View를 통해 클라이언트에 전달한다
- MVC 모델 1과 2 방식이 존재
- MVC 모델 1은 컨트롤러 영역에 View를 같이 구현하는 방식으로 JSP가 처리
- MVC 모델 2는 사용자 요청을 서블릿이 받고 서블릿이 해당 요청의 반환으로 View 또는 Model을 보낸다
   - 

### DI(Dependency Injection)을 설명하세요
- 의존 관계 주입
- 각각의 계층이나 서비스들간의 의존성을 Spring이 대신 연결해준다
- POJO 객체들 사이의 의존관계를 Spring이 알아서 연관성을 맺어준다
- 클래스 사이의 의존관계를 컨테이너가 자동적으로 연결해준다
- DI가 없다면 하나의 모듈을 바꿀 때 다른 모듈도 변경해야한다(수정할 코드가 증가한다)
- OCP, DIP를 가능하게 한다(OCP :  확장엔 열려있고 변경엔 닫침, DIP : 추상화에 의존하고 구체화에 의존 X)
- 클라이언트 코드의 변경없이 기능을 확장

- SOLID의 OCP를 지키기 위해 객체를 역할과 구현으로 분리
- 객체의 역할(인터페이스)을 먼저 만들고 그 역할을 수행하는 구현객체 만들기
- Java에서 역할은 인터페이스이고 구현은 인터페이스를 구현한 클래스이다
- 유저 서비스에서 주문 서비스를 필요로 할 때, 유저 서비스의 코드에서 주문 서비스의 인터페이스를 선언해야한다
- 이 때 인터페이스의 구현체를 정의해야하는데 이는 DIP를 위반한다 (구현체에 의존하기 때문)
- -> 인터페이스의 구현체를 정의하는 객체를 만든다(의존성 주입객체, DI 컨테이너)
- 의존성 주입객체에서 주문 서비스 인터페이스에 실제 구현체를 넣어 인스턴스를 생성하고 유저 서비스에서는 의존성 주입객체의 인스턴스를 받아 사용한다
- 주문 서비스의 구현체를 바꾸면 의존성 주입 객체에서만 바꿔주고 유저 서비스에서의 변경은 없다


### AOP(Aspect Oriented Programming)을 설명하세요
- 관점 중심 프로그래밍
- 여러 곳에서 공통적으로 쓰이는 기능들을 분리하여 개발하고 실행 시 조합할 수 있도록 AOP 지원
- 로그인 인증, 로깅 등


### POJO를 설명하세요
- Plain Old Java Object 직역하면 오래된 방식의 간단한 자바 객체
- JavaEE와 같이 중량 프레임워크에 종속되어있는 무거운 객체를 만드는 것에 반발하여 사용하게 된 용어
- 특정 기술에 종석되어 동작하지 않는 순수한 자바객체
- POJO는 프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스입니다
- 특정환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다
- 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 POJO대상이 될 수 있습니다
- POJO가 아닌 특정 기술에 종속하는 객체들은 가독성과 유지보수에 어려움을 겪고 직접 의존하기 때문에 확장성도 떨어집니다
- 즉 객체지향 설계의 장점을 잃어버리게 되는 것입니다


### DAO와 DTO의 차이를 설명하세요


### Spring JDBC를 이용한 데이터 접근


### Filter와 Interceptor의 차이

- Filter는 DispatcherServlet 외부에 존재하기 때문에 예외가 발생하면 ErrorController에서 처리해야합니다
- Interceptor는 DispatcherServlet 내부에 존재하기 때문에 @ControlllerAdvice를 적용해서 처리할 수 있습니다
- Filter는 doFilter()만 있지만 Interceptor는 prehandle과 posthandle로 분리


### PSA를 설명하세요

> 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조

- Spring에서 동작할 수 있는 라이브러리들은 POJO원칙을 지키게끔 PSA형태의 추상화가 되어있다
- 잘 만든 인터페이스이다
- PSA가 적용된 코드는 다른 기술로 간편하게 바꿀 수 있도록 확정성이 좋고 기술에 특화되어있지 않은 코드를 말한다
- Spring Web MVC, Spring Transaction, Spring Cache등 다양한 PSA 제공

- Spring은 서블릿 어플리케이션이지만 서블릿을 사용자가 볼 수 없다. 단지 @Controller 어노테이션이 붙은 클래스에서 @GetMapping이나 @PostMapping같은 어노테이션으로 요청을 매핑한다
- 내부적으로 서블릿 기반으로 코드가 동작하지만 이는 추상화되어있다. 이처럼 기술을 내부에 숨기고 개발자에게 편의성을 제공하는 것을 Service Abstraction이라 한다
- 더하여 Service Abstraction으로 제공되는 기술을 다른 기술로 간단하게 바꿀 수 있는 확장성을 가진 것이 PSA (Portable Service Abstraction)이다



### 조회 빈이 2개 이상일 때의 문제를 설명하세요

- @Autowired는 타입으로 조회한다
- 만약 DiscountPolicy의 인터페이스 구현체가 두개 이상이고 스프링 빈으로 선언되었을 때 의존관계 자동주입을 하면 어떻게 될까?
- -> NoUniqueBeanDefinitionException이 발생한다
- 이를 해결하는 방법은 세가지
   - Autowired 필드명 매칭
       - 타입은 인터페이스로 두고 필드명을 원하는 빈 이름으로 하면 자동주입 시 해당 빈 이름의 빈이 먼저 매칭된다
    - @Qualifier 사용
      - 추가 구분자를 붙이는 방법이다
      - @Qualifier("특정 빈 이름") 으로 구별한다
   - @Primary 사용
      - @Primary를 붙인 빈이 우선적으로 매칭
