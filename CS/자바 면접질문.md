### 자바 컴파일 과정을 설명하세요

1. 자바 소스코드 실행
2. 자바 컴파일러가 소스코드 컴파일해서 자바 바이트코드로 변환
3. JVM의 클래스로더가 바이트코드를 읽어 JVM에 메모리에 올림
4. 실행엔진이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 실행

### 자바의 캐스팅에 대해 설명하세요


### 자바의 오토박싱과 언박싱에 대해 설명하세요


### String과 StringBuffer와 StringBuilder를 설명하세요
- String은 불변객체
- StringBuffer와 StringBuilder는 가변객체
- StringBuffer는 Multi-thread에 안전, StringBuilder는 Multi-thread에 안전하지

### 자바의 Call by Value와 Call by Reference를 설명하세요
- call by value
  - 함수 호출 시 전달되는 변수값을 복사해서 파라미터로 전달
  - 따라서 함수 안에서 값이 변경되도 외부의 값은 변경되지 않음
- call by reference
   - 함수 호출 시 전달되는 변수의 주소를 파라미터로 전달
   - 함수 안에서 해당 주소의 값을 변경하므로 외부의 값도 변경됨
- Java는 항상 call by value로 값을 넘긴다
- 참조형 변수를 넘길 때 해당 주소 값을 복사해서 넘긴다
- 함수 안에서 참조형 변수를 변경하면 해당 주소의 값이 변경되지 않고 주소 자체가 바뀐다
- 따라서 외부의 변수는 변경되지 않는다

- 요약 : C나 C++은 주소값 자체를 인자로 넘겼을 때 값을 변경하면 새로운 값으로 덮어쓰지만 Java에서는 주소 값을 덮어쓰므로 원본의 값은 영향을 받지 않는다

### JVM의 역할, 동작과정과 메모리 구조를 설명하세요

- JVM은 자바 가상머신으로 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 한다
- 프로그램 메모리를 관리하고 최적화 한다


- JVM 구조
  - 클래스 로더
    - 컴파일 된 바이트 코드를 읽어 메모리에 할당
  - 실행 엔진
    - 바이트 코드를 실행시킴
  - Runtime Data Areas
    - PC Register
    - Stack Area
    - Heap Area
    - Method Area
  - JNI
  - Native Method Interface
 

### 가비지 컬렉션을 설명하세요

- JVM은 GC를 통해 메모리를 관리
- 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할

- JVM의 힙 영역에서 사용하지 않는 객체를 제거
- 힙 영역에는 Eden과 Survivor0, Survivor1, Old 영역이 있는데 Eden에는 새롭게 생성된 인스턴스가 저장되며 이 부분이 꽉차서 MinorGC가 일어났을 때 참조되지 않은 객체를 삭제한다
- 삭제하고 남은 객체들을 Survivor로 이동하며 Survivor의 객체들 또한 MinorGC가 일어나면 참조되지 않은 객체를 삭제하고 나머지를 다른 Survivor으로 이동시킨다
- Survivor에 어느정도 머무를 시 Old로 이동시킨다
- Old 영역에서는 MajorGC가 일어난다

### Primitive 타입과 Reference 타입을 설명하세요

- 자바의 자료형은 기본형 타입과 참조형 타입으로 나뉩니다

- 기본형 (Privimitve Type)
  - 특징 
    - 자료형의 길이가 정해져 있다
    - Null이 될 수 없다
    - 스택 메모리에 저장된다
  - 종류
    - boolean : 1bytes
    - char : 2bytes
    - byte : 1bytes
    - short : 2bytes
    - int : 4bytes
    - long : 8bytes
    - float : 4bytes
    - double : 8bytes

- 참조형 (Reference Type)
  - 특징
    - 기본형 타입을 제외한 모든 타입
    - Object 클래스를 상속

### 컴파일과 런타임을 설명하세요


### 제네릭을 설명하세요


### static과 final을 설명하세요
- static 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 Static영역에 할당된다
- Static 영역에 할당된 메모리는 모든 객체가 공유하여 어디서든지 참조할 수 있다
- 하지만 GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때 까지 메모리가 할당된 채로 계속 존재하여 성능에 악영향을 줄 수 잇다
- static
  - 변수나 상수에 사용 : 객체를 통해 접근하거나 클래스를 통해 접근 가능
  - 메소드에 사용 : 객체 또는 클래스를 통해 접근 가능
  - 클래스 : 클래스 내부의 클래스에 사용 시 외부 클래스를 생성하지 않고도 내부 클래스 사용 가능

- final
  - 변수나 상수에 사용 : 값을 변경할 수 없음
  - 객체에 사용 : 주소값을 변경할 수 없음
  - 메소드에 사용 : 오버라이딩할 수 없음
  - 클래스에 사용 : 상속할 수 없음


### equals 와 == 의 차이를 설명하세요
- equals는 객체의 주소를 비교하고, ==는 객체의 값을 비교합니다


### 직렬화와 역직렬화를 설명하세요
- 직렬화란 자바 시스템 내부에서 사용되는 객체나 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트형태로 변환하는 기술
- 역직렬화는 반대로 바이트형태의 데이터를 자바 객체로 변환하는 기술
- JVM 메모리 내부에서의 이동이 아닌 외부로 전송할 때 주로 사용

### 클래스와 객체, 인스턴스의 차이를 설명하세요
- 클래스는 객체를 정의하는 틀 혹은 설계도라는 의미로 사용됩니다
- 객체는 클래스가 정의하는 정보를 가진 개체이며 이 객체가 실제로 메모리를 할당 받았을 때 인스턴스라고 

### Wrapper 클래스를 설명하세요


### 오버로딩과 오버라이딩을 설명하세요
- 오버라이딩은 상위 클래스의 메소드를 재정의하는 것 (컴파일 다형성)
- 오버로딩은 같은 클래스내에 메소드이름은 같지만 매개변수 타입이나 개수를 다르게 구현할 수 있는 것 (런타임 다형성)

### 인터페이스와 추상클래스를 설명하세요
- 인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장, 다중 상속이 가능
- 추상클래스는 공통된 개념을 표현할 때 주로 사용, 단일 상속만 가능

### Multi-Tread에서 개발할 때 고려할 점을 설명하세요


### 어노테이션을 설명하세요

