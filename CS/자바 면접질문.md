### 자바 컴파일 과정을 설명하세요

1. 자바 소스코드 실행
2. 자바 컴파일러가 소스코드 컴파일해서 자바 바이트코드로 변환
3. JVM의 클래스로더가 바이트코드를 읽어 JVM에 메모리에 올림
4. 실행엔진이 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 실행

### 자바의 캐스팅에 대해 설명하세요
> 캐스팅(형변환)은 자료형을 변환하는 연산

- 기본형은 기본형끼리, 참조형은 참조형끼리 가능

- 캐스팅이 필요한 이유
  - 다형성 때문 (하나의 객체가 여러 자료형 타입을 가지는 것)
  - 부모클래스의 참조변수로 자식클래스의 타입 인스턴스를 참조가능

- 업 캐스팅(묵시적 형변환)
  - 기본형
    - 정수형 (byte -> short -> (char ->) int -> long)
    - 실수형 (float -> double)
  - 참조형
    - Parent p = new Child();
    - 자식은 부모의 속성을 모두 가지고 있다
- 다운 캐스팅(암시적 형변환)
    - 기본형
      - 정수형 : 반대
      - 실수형 : 반대
    - 참조형
      - Child c = (Child) new Parent(); -> 런타임 오류 (Parent 객체가 Child의 속성을 가지지 않기 때문)
      ```
      Parent p = new Child c;
      
      p instanceof Parent // true
      p instanceof Child // true
      
      Child c = (Child) p; // 가능
      
      ```

### 자바의 오토박싱과 언박싱에 대해 설명하세요

- 자바에는 기본형과 Wrapper 클래스가 존재
- Wrapper
  - 기본타입의 데이터를 객체로 표현한 것
  - 메소드의 인수로 객체타입이 요구될 때 주로 사용
  - 제네릭을 활용하기 위해 기본 형을 Object를 상속하는 참조 형으로 변환

- 박싱
  -  기본타입의 데이터를 Wrapper 클래스로 만드는 동작
  -  int i = 10;
  -  Integer num = new Integer(i);

- 언박싱
  - Wrapper 클래스를 기본타입으로 변환
  - Integer num = new Integer(10);
  - int i = num.intValue();

- 오토박싱
  - 자바 컴파일러가 자동으로 박싱해줌
  - int i = 10;
  - Integer num = i;

- 오토 언박싱
  - Integer num = new Integer(10);
  - int i = num;

### String과 StringBuffer와 StringBuilder를 설명하세요
- String은 불변객체
- StringBuffer와 StringBuilder는 가변객체
- StringBuffer는 Multi-thread에 안전, StringBuilder는 Multi-thread에 안전하지

### 자바의 Call by Value와 Call by Reference를 설명하세요
- call by value
  - 함수 호출 시 전달되는 변수값을 복사해서 파라미터로 전달
  - 따라서 함수 안에서 값이 변경되도 외부의 값은 변경되지 않음
- call by reference
   - 함수 호출 시 전달되는 변수의 주소를 파라미터로 전달
   - 함수 안에서 해당 주소의 값을 변경하므로 외부의 값도 변경됨
- Java는 항상 call by value로 값을 넘긴다
- 참조형 변수를 넘길 때 해당 주소 값을 복사해서 넘긴다
- 함수 안에서 참조형 변수를 변경하면 해당 주소의 값이 변경되지 않고 주소 자체가 바뀐다
- 따라서 외부의 변수는 변경되지 않는다

- 요약 : C나 C++은 주소값 자체를 인자로 넘겼을 때 값을 변경하면 새로운 값으로 덮어쓰지만 Java에서는 주소 값을 덮어쓰므로 원본의 값은 영향을 받지 않는다

### JVM의 역할, 동작과정과 메모리 구조를 설명하세요

- JVM은 자바 가상머신으로 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 한다
- 프로그램 메모리를 관리하고 최적화 한다


- JVM 구조
  - 클래스 로더
    - 컴파일 된 바이트 코드를 읽어 메모리에 할당
  - 실행 엔진
    - 바이트 코드를 실행시킴
  - Runtime Data Areas
    - PC Register
    - Stack Area
    - Heap Area
    - Method Area
  - JNI
  - Native Method Interface
 

### 가비지 컬렉션을 설명하세요

- JVM은 GC를 통해 메모리를 관리
- 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할

- JVM의 힙 영역에서 사용하지 않는 객체를 제거
- 힙 영역에는 Eden과 Survivor0, Survivor1, Old 영역이 있는데 Eden에는 새롭게 생성된 인스턴스가 저장되며 이 부분이 꽉차서 MinorGC가 일어났을 때 참조되지 않은 객체를 삭제한다
- 삭제하고 남은 객체들을 Survivor로 이동하며 Survivor의 객체들 또한 MinorGC가 일어나면 참조되지 않은 객체를 삭제하고 나머지를 다른 Survivor으로 이동시킨다
- Survivor에 어느정도 머무를 시 Old로 이동시킨다
- Old 영역에서는 MajorGC가 일어난다

### Primitive 타입과 Reference 타입을 설명하세요

- 자바의 자료형은 기본형 타입과 참조형 타입으로 나뉩니다

- 기본형 (Privimitve Type)
  - 특징 
    - 자료형의 길이가 정해져 있다
    - Null이 될 수 없다
    - 스택 메모리에 저장된다
  - 종류
    - boolean : 1bytes
    - char : 2bytes
    - byte : 1bytes
    - short : 2bytes
    - int : 4bytes
    - long : 8bytes
    - float : 4bytes
    - double : 8bytes

- 참조형 (Reference Type)
  - 특징
    - 기본형 타입을 제외한 모든 타입
    - Object 클래스를 상속

### 컴파일타임과 런타임을 설명하세요

- 컴파일은 소스코드를 기계어 코드로 변환하는 것을 말하는데 이러한 편집 과정을 컴파일 타입이라 한다
- 런타임은 컴파일이 끝난 프로그램을 사용자에 의해 실행할 때를 말한다

- 컴파일 타임 에러는 프로그램이 성공적으로 컴파일 되는 것을 방해하는 코드 문법오류나 잘못된 타입체크로 인한 오류가 있습니다.
- 프로그램이 실행중에 예상치 못한 에러가 발생할 수 있는데 이를 런타임 오류라고 합니다. 
- 0 나누기 오류, 널 참조 오류, 메모리 부족 오류 등이 있습니다.

### 제네릭을 설명하세요
> 모든 종류의 타입을 다룰 수 있도록 일반화된 타입 매개변수로 클래스나 메서드를 선언하는 기법

- 제네릭이 없을 때 여러 타입을 사용하는 클래스나 메소드의 매개변수로 Object 타입을 사용
- 이 경우 Object 객체를 다시 원하는 타입으로 변경해야 했고 이는 개발자가 직접 작성하기 때문에 오류가 발생할 경우가 있다
- 제네릭을 사용하면 직접 형변환을 할 필요가 없어 타입 변환이나 검사등을 하지 않아도 된다


### static과 final을 설명하세요
- static 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 Static영역에 할당된다
- Static 영역에 할당된 메모리는 모든 객체가 공유하여 어디서든지 참조할 수 있다
- 하지만 GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때 까지 메모리가 할당된 채로 계속 존재하여 성능에 악영향을 줄 수 잇다
- static
  - 변수나 상수에 사용 : 객체를 통해 접근하거나 클래스를 통해 접근 가능
  - 메소드에 사용 : 객체 또는 클래스를 통해 접근 가능
  - 클래스 : 클래스 내부의 클래스에 사용 시 외부 클래스를 생성하지 않고도 내부 클래스 사용 가능

- final
  - 변수나 상수에 사용 : 값을 변경할 수 없음
  - 객체에 사용 : 주소값을 변경할 수 없음
  - 메소드에 사용 : 오버라이딩할 수 없음
  - 클래스에 사용 : 상속할 수 없음


### equals 와 == 의 차이를 설명하세요
- equals는 객체의 값과 주소를 비교하고, ==는 객체의 값을 비교합니다


### 직렬화와 역직렬화를 설명하세요
- 직렬화란 자바 시스템 내부에서 사용되는 객체나 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트형태로 변환하는 기술
- 역직렬화는 반대로 바이트형태의 데이터를 자바 객체로 변환하는 기술
- JVM 메모리 내부에서의 이동이 아닌 외부로 전송할 때 주로 사용

### 클래스와 객체, 인스턴스의 차이를 설명하세요
- 클래스는 객체를 정의하는 틀 혹은 설계도라는 의미로 사용됩니다
- 객체는 클래스가 정의하는 정보를 가진 개체이며 이 객체가 실제로 메모리를 할당 받았을 때 인스턴스라고 


### 오버로딩과 오버라이딩을 설명하세요
- 오버라이딩은 상위 클래스의 메소드를 재정의하는 것 (컴파일 다형성)
- 오버로딩은 같은 클래스내에 메소드이름은 같지만 매개변수 타입이나 개수를 다르게 구현할 수 있는 것 (런타임 다형성)

### 인터페이스와 추상클래스를 설명하세요
- 인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장, 다중 상속이 가능
- 추상클래스는 공통된 개념을 표현할 때 주로 사용, 단일 상속만 가능

### Multi-Tread에서 개발할 때 고려할 점을 설명하세요


### 어노테이션을 설명하세요


### String Pool을 설명하세요

- 자바에서 String을 생성하는 방법은 두 가지가 있다
  - String Literal (String a = "abc";)
  - new 연산자 (String a = new String("abc");)

- new 연산자로 String을 생성하면 다른 객체 생성과 같이 Heap영역에 저장된다
- 같은 문자열을 생성해도 new 연산자로 생성 시 새로운 메모
- String Literal로 String을 생성하면 String pool에 저장된다
- String Literal로 생성할 때 먼저 해당 문자열이 String pool에 존재하는지 확인하고 존재할 시 해당 값을 참조하기 때문에 new 연산자로 생성할 때보다 메모리 사용을 줄일 수 있다.
```
String dog1 = "dog";
String dog2 = "dog";
System.out.println(dog1==dog2); // true

String cat1 = new String("cat");
String cat2 = new String("cat");
System.out.println(cat1==cat2); // false

```
