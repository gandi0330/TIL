### OSI 7계층을 설명하세요

> OSI 7계층은 데이터를 주고받기 위해 개발된 네트워크 프로토콜들을 계층별로 나누어 설명한 모델입니다.
- 물리 계층 : 하드웨어 전송 기술
- 데이터 링크 계층 : 물리적 주소인 Mac주소로 데이터 전송
- 네트워크 계층 : 논리적 주소인 Ip주소로 데이터 전송
- 전송 계층 : TCP와 UDP 프로토콜을 통해 프로그램들이 전송할 수 있도록 통신을 활성화
- 세션 계층 : 데이터가 통신하기 위한 논리적 연결을 담당
- 표현 계층 : 파일 인코딩, 압축, 암호화
- 응용 계층 : 일반적인 응용 서비스를 수행

<br>


### TCP/IP 4계층을 설명하세요
- 응용 계층 : FTP, HTTP, SSH, SMTP, DNS 등 응용프로그램이 사용되는 프로토콜 계층
- 전송 계층 : TCP, UDP로 송신자와 수신자를 연결하는 통신 서비스 제공
- 인터넷 계층 : 장치로부터 받은 네트워크 패킷을 IP 주소로 지정된 목적지에 전송, IP,ARP,ICMP등 
- 링크 계층 : 전선, 광섬유, 무선 등 실질적인 데이터를 전달하며 장치 간 신호를 주고받는 규칙을 정함

<br>

### TCP와 UDP의 개념 및 차이점을 설명하세요

#### TCP
- 연결형 서비스로 가상회선 방식으로 통신한다
  - 가상회선 방식 : 특정 회선을 결정하고 패킷들이 해당 회선으로 전달되어 순서대로 도착하는 방식
- 흐름제어 및 혼잡제어를 제공한다
  - 흐름제어 : 수신자가 감당하지 못할 만큼의 데이터를 보내지 않도록 데이터 처리 속도를 조절하는 것
  - 혼잡제어 : 네트워크 내의 데이터가 넘치지 않도록 조절하는 것
- UDP보다 느리지만 높은 신뢰성을 가진다


#### UDP
- 비연결형 서비스로 데이터그램 방식으로 통신한다
  - 데이터그램 통신 방식 : 연결을 위한 경로가 없어 각 패킷이 다른 경로로 전송된다
    - 경로를 정하지 않아서 빠르다
    - 패킷마다 경로가 달라 순서대로 도착하지 않는다
- TCP보다 빠르지만 신뢰성이 낮다

<br>

### TCP의 신뢰성 보장 방법을 설명하세요

- TCP는 장치들 사이에서 논리적인 접속을 성립하기 위해 연결을 설정하여 신뢰성을 보장한다
- TCP의 연결 -> 3 way handshake
- TCP의 연결 해제 -> 4 way handshake


#### 3 way handshake
- 양쪽 모두 서로가 데이터를 전송할 준비가 되었다는 것을 알 수 있도록 보장한다

1. 클라이언트가 서버에 ISN을 SYN에 담아 전송
2. 서버가 클라이언트의 SYN을 받고 서버의 ISN을 SYN에 담고, 클라이언트의 ISN에 1 더한 값을 ACK에 담아 전송 
3. 클라이언트는 서버의 ISN+1한 값을 ACK에 담아 전송



#### 4 way handshake
1. 클라이언트가 연결을 닫으려 할 때 FIN을 전송, FIN_WAIT_1 상태로 변환
2. 서버는 ACK를 보내고 CLOSE_WAIT상태로 변환, 클라이언트가 ACK를 받으면 FIN_WAIT_2 상태로 변환
3. 서버가 2번 이후 일정 시간 뒤에 FIN을 전송
4. 클라이언트는 FIN을 받아 TIME_WAIT상태로 변환, 서버로 ACK를 보내면 서버는 CLOSED 상태로 변환, 이후 클라이언트는 일정 시간 뒤 연결이 닫히고 모든 자원이 연결 해제

- FIN_WAIT_1 : 클라이언트가 서버에게 연결해제를 요청한 뒤 서버의 응답을 기다리는 시간
- FIN_WAIT_2 : 클라이언트의 해제 요청에 대해 서버가 알겠다고 응답한 시간부터 서버에서 보낼 패킷을 다 보낸 뒤 FIN을 보내기 전 까지의 시간 
- TIME_WAIT를 하는 이유 : 지연된 패킷이 도달하지 못하고 연결을 해제할 경우 데이터의 무결성 문제가 발생하기 때문

- 플래그(ACK, SYN, FIN 등)는 TCP의 Header에 플래그 비트로 표현

<br>

### GET과 POST의 차이를 설명하세요

> GET과 POST는 HTTP 프로토콜을 이용하여 데이터를 전달할 때 사용하는 메서드입니다

#### GET Method
- 개념
  - 정보를 조회하기 위한 메서드
  - Select
  - URL에 요청 정보를 붙여 전송
    - 대용량의 데이터를 전송하기 어렵다
    - 보안상 취약하다
  - 설계 원칙상 GET 방식은 서버에 여러번 요청하더라도 동일한 응답을 받아야 한다

#### POST Method
- 개념
  - 값이나 상태를 바꾸기 위한 메서드
  - Inser, Update, Delete
  - Body안에 요청 정보를 담아 전송하기 때문에 대용량의 데이터를 전송할 수 있다
  - GET방식보다 보안상 안전하다(완벽하진 않지만)

<br>

### 네트워크 토폴로지의 종류와 특징을 설명하세요

- 트리 토폴로지
  - 트리 형태로 배치한 네트워크 구성
  - 노드의 추가와 삭제가 쉽다
  - 특정 노드에 트래픽이 집중되면 하위 노드에 영향을 끼친다
 
- 버스 토폴로지
  - 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 네트워크 구성
  - LAN에서 사용
  - 설치 비용이 적고 신뢰성이 우수
  - 노드를 추가하거나 삭제하기 쉽다
  - 중앙 통신 회선에 문제가 생기면 모두 영향을 받는다


- 스타 토폴로지
  - 중앙에 있는 노드에 모두 연결된 네트워크 구성
  - 노드를 추가하거나 에러를 탐지하기 쉽고 패킷 충돌 가능성이 적다
  - 중앙 노드를 제외한 노드가 장애가 생겨도 영향을 끼치지 않는다
  - 중앙 노드에 장애가 발생하면 네트워크를 사용할 수 없다
  - 설치 비용이 고가이다

- 링형 토폴로지
  - 각각의 노드가 양 옆의 두 노드와 연결되어 링형태를 가진 네트워크 구성
  - 각 노드는 링 모양의 길을 통해 패킷을 처리
  - 회선에 장애가 생기면 네트워크 사용 불가능

- 메시 토폴로지
  - 망형 토폴로지라고도 부르며 각 노드가 여러 노드와 그물망처럼 연결되어있는 네트워크 구성
  - 노드의 추가가 어렵고 비용이 고가
  - 노드의 장애에 안전하고 트래픽 분산처리도 가능

<br>

### CORS란
- Cross Origin Resource Sharing은 보안적인 이유로 cross-origin HTTP 요청을 제한한다
- cross-origin이란 다음 중 한 가지라도 다른 경우를 말한다
  - http와 https는 다르다
  - domain.com과 other-domain.com은 다르다
  - 포트 번호가 8080과 3000은 다르다
- cross-origin 요청을 하려면 서버의 동의가 필요한데 이를 설정하기 위해 HTTP-header를 설정하는 것을 CORS라고 한다
- CORS 없이 모든 곳에서 데이터를 요청할 수 있게 되면 다른 사이트에서 원래 사이트를 흉내내어 정보를 탈취할 수 있다

<br>

### 쿠키와 세션

- HTTP 프로토콜의 특징
  - 비연결 지향
    - 클라이언트가 request를 보내면 서버는 응답한 뒤 바로 연결을 끊는다
  - 상태정보 유지 x
    - 연결을 끊는 순간 통신이 끝나며 상태 정보를 유지하지 않는다

- 쿠키와 세션의 필요성
  - 모든 요청간의 의존성이 없어서 현재 접속한 사용자와 이전에 접속한 사용자가 같은 사용자인지 알 수있는 방법이 없다
  - 연결을 유지하지 않기 때문에 클라이언트는 매 요청마다 인증을 해야한다
  - 연결을 유지하지 않고 사용자의 정보를 유지하기 위지하기 위해서는 (상태를 유지) 쿠키과 세션이 필요하다

#### 쿠키
- 클라이언트 로컬에 key:value로 저장되는 파일
- 클라이언트의 상태 정보를 브라우저에 저장하고 이를 참조한다
- 사용 예시 : 아이디, 비밀번호 저장, 비회원의 장바구니

#### 세션
- 일정 시간동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 이를 유지하는 것
- 웹 브라우저를 통해 서버에 접속한 이후로부터 브라우저를 종료할 때 까지 유지
- 사용 예시 : 로그인

#### 쿠키와 세션 차이
- 저장 위치 : 쿠키(클라이언트), 세션(서버)
- 보안 : 쿠키(보안에 취약), 세션(쿠키보다는 안전)
- 라이프사이클 : 쿠키(만료시간이 상대적으로 길고 계속 남는다), 세션(만료시간이 있지만 브라우저 종료시 삭제)

<br>

### 로드밸런싱

- 하나의 서버로 사용자의 모든 트래픽을 감당하기엔 어려움이 있다
- 대응 방안으로 Scale-up과 Scale-out이 있다
  - Scale-up : 하드웨어의 성능을 높이기
  - Scale-out : 하드웨어를 추가하기
- Scale-out 시 무중단 서비스를 제공할 수 있고 비용이 저렴하여 효과적이다
- 이 때 여러 서버에게 균등하게 트래픽을 분산하는 것이 로드 밸런싱이다

- 로드 밸런서가 서버를 선택하는 방식
  - 라운드 로빈 : 단순하게 번갈아가며 트래픽을 분산 
  - Least Connections : 연결 개수가 가장 적은 서버를 선택
  - Source : 사용자 IP를 해싱하여 분배(각 사용자가 항상 같은 서버로 연결되는 것을 보장)


<br>

### HTTP/1, HTTP/2, HTTP/3, HTTPS의 특징을 각각 설명하세요

#### HTTP/1.0
- 한 연결 당 하나의 요청을 처리하도록 설계되었다
- 서버로부터 파일을 가져올 때 마다 TCP를 연결해야 하기 때문에 RTT(패킷 왕복시간)이 증가한다
- 이를 해결하기 위해 이미지 스플리팅, 코드압축, 이미지 인코딩 등을 사용

#### HTTP/1.1
- 매번 TCP 연결을 하지 않고 한번 TCP 초기화 후 keep-alive라는 옵션으로 여러 개의 파일을 송수신할 수 있도록 바뀜
- HOL Blocking 현상 발생 (같은 큐의 패킷이 그 앞의 패킷에 의해 지연되는 현상)


#### HTTP/2
- HTTP/1보다 지연시간을 줄이고 응답시간을 빠르게 하며 멀티플렉싱, 헤더 압축, 우선순위 처리 등을 지원
- 멀티 플렉싱을 통해 단일 연결로 여러 요청을 처리할 수 있다
- HTTP/1의 헤더를 압축하였다
- 클라이언트에서 서버에 요청을 해야만 파일을 다운받을 수 있었지만 클라이언트 요청 없이 서버에서 리소스를 제공할 수 있다


#### HTTPS
- HTTP/2는 HTTPS 위에서 동작하며 HTTPS는 애플리케이션 계층과 전송 계층 사이에 SSL/TLS계층을 넣은 신뢰할 수 있는 HTTP 요청을 뜻한다

- SSL/TLS
  - SSL/TLS는 SSL부터 시작하여 버전이 올라가며 TLS로 명칭이 바뀌었지만 통칭하여 SSL/TLS로 부른다
  - SSL/TLS는 클라이언트와 서버가 통신할 때 제 3자가 메세지를 도청하거나 변조하지 못하도록 한다

- HTTPS 통신 흐름
  1. 서버에서 공개키와 개인키를 만든다
  2. 신뢰할 수 있는 CA 기업을 선택하고 그 기업에게 서버의 공개키를 제공한다
  3. CA 기업은 해당 기업의 이름과 서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화 하여 서버에 제공한다
  4. 서버는 암호화된 인증서를 받아 클라이언트에게 요청이 오면 인증서를 준다
  5. 클라이언트의 브라우저는 CA 기업의 공개키를 가지고 있으므로 해당 공개키로 인증서를 해독하여 서버의 공개키를 얻는다
  6. 클라이언트가 얻은 서버의 공개키로 요청을 암호화 하여 서버에게 요청한다
  7. 서버는 개인키로 클라이언트의 요청을 
